import React, { forwardRef, useRef, useState, useEffect, useCallback } from 'react';
import { View, Text, Input, ScrollView } from '@tarojs/components';
import { datePickerStyles } from './DatePicker.styles';
import type {
  DatePickerProps,
  DatePickerRef,
  DatePickerSize,
  DatePickerVariant,
  DatePickerStatus,
  DatePickerFormat,
  DateRange,
} from './DatePicker.types';

/** æ—¥æœŸé€‰æ‹©å™¨ç»„ä»¶ */
export const DatePickerComponent = forwardRef<DatePickerRef, DatePickerProps>((props, ref) => {
  const {
    value,
    defaultValue,
    onChange,
    range = false,
    valueRange,
    defaultRangeValue,
    onRangeChange,
    format = 'YYYY-MM-DD',
    placeholder,
    rangePlaceholder = ['å¼€å§‹æ—¥æœŸ', 'ç»“æŸæ—¥æœŸ'],
    disabledDate,
    disabledTime,
    size = 'md',
    variant = 'outlined',
    status = 'normal',
    allowClear = true,
    readOnly = false,
    disabled = false,
    className,
    style,
    onFocus,
    onBlur,
    onClick,
    onOpenChange,
    minDate,
    maxDate,
    showTime = false,
    timeFormat = 'HH:mm:ss',
    dateRender,
    renderExtraFooter,
    accessible = true,
    accessibilityLabel,
    accessibilityRole = 'combobox',
    ...restProps
  } = props;

  const pickerRef = useRef<HTMLDivElement>(null);
  const [internalValue, setInternalValue] = useState<Date | null>(defaultValue || null);
  const [internalRangeValue, setInternalRangeValue] = useState<DateRange | null>(defaultRangeValue || null);
  const [isOpened, setIsOpened] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [currentMonth, setCurrentMonth] = useState(new Date());
  const [hoveredDate, setHoveredDate] = useState<Date | null>(null);

  // åŒæ­¥å¤–éƒ¨å€¼
  useEffect(() => {
    if (value !== undefined) {
      setInternalValue(value);
    }
  }, [value]);

  useEffect(() => {
    if (valueRange !== undefined) {
      setInternalRangeValue(valueRange);
    }
  }, [valueRange]);

  // æ ¼å¼åŒ–æ—¥æœŸ
  const formatDate = useCallback(
    (date: Date | null): string => {
      if (!date) return '';


    const year = date.getFullYear()
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');


    switch (format) {
        case 'YYYY-MM-DD':
          return `${year}-${month}-${day}`;
        case 'YYYY/MM/DD':
          return `${year}/${month}/${day}`;
        case 'DD/MM/YYYY':
          return `${day}/${month}/${year}`;
        case 'MM/DD/YYYY':
          return `${month}/${day}/${year}`;
        case 'YYYYå¹´MMæœˆDDæ—¥':
          return `${year}å¹´${month}æœˆ${day}æ—¥`;
        default:
          return `${year}-${month}-${day}`;
      }
    },
    [format],
  );

  // è§£ææ—¥æœŸå­—ç¬¦ä¸²
  const parseDate = useCallback((dateString: string): Date | null => {
    try {
      const date = new Date(dateString);
      return isNaN(date.getTime()) ? null : date;
    } catch {
      return null;
    }
  }, []);

  // æ—¥æœŸæ˜¯å¦åœ¨èŒƒå›´å†…
  const isDateInRange = useCallback(
    (date: Date): boolean => {
      const timestamp = date.getTime();

    if (minDate && timestamp < minDate.getTime()) return false
      if (maxDate && timestamp > maxDate.getTime()) return false;


    if (disabledDate && disabledDate(date)) return false

    return true
    },
    [minDate, maxDate, disabledDate],
  );

  // æ—¥æœŸæ˜¯å¦ç›¸ç­‰
  const isSameDate = useCallback((date1: Date, date2: Date): boolean => {
    return (
      date1.getFullYear() === date2.getFullYear() &&
      date1.getMonth() === date2.getMonth() &&
      date1.getDate() === date2.getDate()
    );
  }, []);

  // è·å–æœˆä»½ä¿¡æ¯
  const getMonthInfo = useCallback((year: number, month: number) => {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const days = lastDay.getDate();
    const startDay = firstDay.getDay();

    return { firstDay, lastDay, days, startDay };
  }, []);

  // è·å–æœˆä»½æ—¥æœŸæ•°ç»„
  const getMonthDays = useCallback(
    (year: number, month: number): (Date | null)[] => {
      const { firstDay, days, startDay } = getMonthInfo(year, month);
      const daysArray: (Date | null)[] = [];


    // ä¸Šæœˆæ—¥æœŸ
      const prevMonth = month === 0 ? 11 : month - 1;
      const prevYear = month === 0 ? year - 1 : year;
      const prevMonthDays = getMonthInfo(prevYear, prevMonth).days;


    for (let i = startDay - 1; i >= 0; i--) {
        daysArray.push(new Date(prevYear, prevMonth, prevMonthDays - i));
      }

    // å½“æœˆæ—¥æœŸ
      for (let i = 1; i <= days; i++) {
        daysArray.push(new Date(year, month, i));
      }

      // ä¸‹æœˆæ—¥æœŸ
      const nextMonth = month === 11 ? 0 : month + 1;
      const nextYear = month === 11 ? year + 1 : year;
      const remainingDays = 42 - daysArray.length;


    for (let i = 1; i <= remainingDays; i++) {
        daysArray.push(new Date(nextYear, nextMonth, i));
      }


    return daysArray
    },
    [getMonthInfo],
  );

  // å¤„ç†æ—¥æœŸç‚¹å‡»
  const handleDateClick = useCallback(
    (date: Date) => {
      if (!isDateInRange(date)) return;


    if (range) {
        if (!internalRangeValue) {
          setInternalRangeValue({ start: date, end: date });
        } else {
          const newRange = {
            start: date.getTime() < internalRangeValue.start.getTime() ? date : internalRangeValue.start,
            end: date.getTime() >= internalRangeValue.start.getTime() ? date : internalRangeValue.start,
          };
          setInternalRangeValue(newRange);
          onRangeChange?.(newRange, [formatDate(newRange.start), formatDate(newRange.end)]);
        }
      } else {
        setInternalValue(date);
        onChange?.(date, formatDate(date));
        setIsOpened(false);
      }
    },
    [range, internalRangeValue, isDateInRange, formatDate, onChange, onRangeChange],
  );

  // å¤„ç†è¾“å…¥æ¡†ç‚¹å‡»
  const handleInputClick = useCallback(
    (event: ITouchEvent) => {
      if (disabled || readOnly) return;


    setIsOpened(!isOpened)
      onClick?.(event);
      onOpenChange?.(!isOpened);
    },
    [disabled, readOnly, isOpened, onClick, onOpenChange],
  );

  // å¤„ç†æ¸…é™¤æŒ‰é’®ç‚¹å‡»
  const handleClearClick = useCallback(
    (event: ITouchEvent) => {
      event.stopPropagation();


    if (range) {
        setInternalRangeValue(null);
        onRangeChange?.(null, ['', '']);
      } else {
        setInternalValue(null);
        onChange?.(null, '');
      }
    },
    [range, onChange, onRangeChange],
  );

  // å¤„ç†æœˆä»½åˆ‡æ¢
  const handleMonthChange = useCallback(
    (direction: 'prev' | 'next') => {
      const newMonth = new Date(currentMonth);
      if (direction === 'prev') {
        newMonth.setMonth(newMonth.getMonth() - 1);
      } else {
        newMonth.setMonth(newMonth.getMonth() + 1);
      }
      setCurrentMonth(newMonth);
    },
    [currentMonth],
  );

  // æ¸²æŸ“æ—¥å†å¤´éƒ¨
  const renderCalendarHeader = () => {
    const year = currentMonth.getFullYear();
    const month = currentMonth.getMonth();
    const monthNames = [
      'ä¸€æœˆ',
      'äºŒæœˆ',
      'ä¸‰æœˆ',
      'å››æœˆ',
      'äº”æœˆ',
      'å…­æœˆ',
      'ä¸ƒæœˆ',
      'å…«æœˆ',
      'ä¹æœˆ',
      'åæœˆ',
      'åä¸€æœˆ',
      'åäºŒæœˆ'
    ];

    return (
      <View className="taro-uno-datepicker__calendar-header">
        <View
          className="taro-uno-datepicker__calendar-nav taro-uno-datepicker__calendar-nav--prev"
          onClick={() => handleMonthChange('prev')}
        >
          &lt;
        </View>
        <View className="taro-uno-datepicker__calendar-title">
          {year}å¹´ {monthNames[month]}
        </View>
        <View
          className="taro-uno-datepicker__calendar-nav taro-uno-datepicker__calendar-nav--next"
          onClick={() => handleMonthChange('next')}
        >
          &gt;
        </View>
      </View>
    );
  };

  // æ¸²æŸ“æ˜ŸæœŸæ ‡é¢˜
  const renderWeekHeaders = () => {
    const weekDays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];

    return (
      <View className="taro-uno-datepicker__calendar-weekdays">
        {weekDays.map((day, index) => (
          <View key={index} className="taro-uno-datepicker__calendar-weekday">
            {day}
          </View>
        ))}
      </View>
    );
  };

  // æ¸²æŸ“æ—¥æœŸå•å…ƒæ ¼
  const renderDateCell = (date: Date | null, index: number) => {
    if (!date) {
      return (
        <View
          key={`empty-${index}`}
          className="taro-uno-datepicker__calendar-cell taro-uno-datepicker__calendar-cell--empty"
        />
      );

    const isCurrentMonth = date.getMonth() === currentMonth.getMonth();
    const isToday = isSameDate(date, new Date());
    const isSelected = range
      ? internalRangeValue &&
        (isSameDate(date, internalRangeValue.start) ||
          isSameDate(date, internalRangeValue.end) ||
          (date.getTime() > internalRangeValue.start.getTime() && date.getTime() < internalRangeValue.end.getTime()))
      : internalValue && isSameDate(date, internalValue);
    const isDisabled = !isDateInRange(date);
    const isHovered = hoveredDate && isSameDate(date, hoveredDate);

    const cellClassName = [
      'taro-uno-datepicker__calendar-cell',
      !isCurrentMonth && 'taro-uno-datepicker__calendar-cell--other-month',
      isToday && 'taro-uno-datepicker__calendar-cell--today',
      isSelected && 'taro-uno-datepicker__calendar-cell--selected',
      isDisabled && 'taro-uno-datepicker__calendar-cell--disabled',
      isHovered && 'taro-uno-datepicker__calendar-cell--hovered',
    ]
      .filter(Boolean)
      .join(' ');

    return (
      <View
        key={date.getTime()}
        className={cellClassName}
        onClick={() => !isDisabled && handleDateClick(date)}
        onMouseEnter={() => setHoveredDate(date)}
        onMouseLeave={() => setHoveredDate(null)}
      >
        {dateRender ? dateRender(date) : date.getDate()}
      </View>
    );
  };

  // æ¸²æŸ“æ—¥å†
  const renderCalendar = () => {
    const year = currentMonth.getFullYear();
    const month = currentMonth.getMonth();
    const days = getMonthDays(year, month);

    return (
      <View className="taro-uno-datepicker__calendar">
        {renderCalendarHeader()}
        {renderWeekHeaders()}
        <View className="taro-uno-datepicker__calendar-days">
          {days.map((date, index) => renderDateCell(date, index))}
        </View>
        {renderExtraFooter && <View className="taro-uno-datepicker__calendar-footer">{renderExtraFooter()}</View>}
      </View>
    );
  };

  // æ¸²æŸ“è¾“å…¥æ¡†
  const renderInput = () => {
    const displayValue = range
      ? internalRangeValue
        ? `${formatDate(internalRangeValue.start)} - ${formatDate(internalRangeValue.end)}`
        : ''
      : formatDate(internalValue);

    return (
      <View
        className={`taro-uno-datepicker__input-wrapper ${
          isFocused ? 'taro-uno-datepicker__input-wrapper--focused' : ''
        }`}
        onClick={handleInputClick}
      >
        {range ? (
          <View className="taro-uno-datepicker__range-inputs">
            <Input
              className="taro-uno-datepicker__input"
              value={internalRangeValue ? formatDate(internalRangeValue.start) : ''}
              placeholder={rangePlaceholder[0]}
              disabled={disabled}
              readOnly={readOnly}
            />
            <Text className="taro-uno-datepicker__range-separator">-</Text>
            <Input
              className="taro-uno-datepicker__input"
              value={internalRangeValue ? formatDate(internalRangeValue.end) : ''}
              placeholder={rangePlaceholder[1]}
              disabled={disabled}
              readOnly={readOnly}
            />
          </View>
        ) : (
          <Input
            className="taro-uno-datepicker__input"
            value={displayValue}
            placeholder={placeholder || 'è¯·é€‰æ‹©æ—¥æœŸ'}
            disabled={disabled}
            readOnly={readOnly}
          />
        )}

        {allowClear && displayValue && !disabled && !readOnly && (
          <View
            className="taro-uno-datepicker__clear-button"
            onClick={handleClearClick}
          >
            Ã—
          </View>
        )}

        <View className="taro-uno-datepicker__calendar-icon">ğŸ“…</View>
      </View>
    );
  };

  // ç”Ÿæˆæ ·å¼
  const pickerStyle = datePickerStyles.getStyle({
    size,
    variant,
    status,
    disabled,
    readOnly,
    style: style || {},
  });

  // ç”Ÿæˆç±»å
  const pickerClassName = datePickerStyles.getClassName({
    size,
    variant,
    status,
    disabled,
    readOnly,
    opened: isOpened,
    focused: isFocused,
    className: className || '',
  });

  // æš´éœ²ç»™å¤–éƒ¨çš„å¼•ç”¨æ–¹æ³•
  React.useImperativeHandle(
    ref,
    () => ({
      element: pickerRef.current,
      getValue: () => internalValue,
      setValue: (value) => {
        setInternalValue(value);
        onChange?.(value, formatDate(value));
      },
      getRangeValue: () => internalRangeValue,
      setRangeValue: (value) => {
        setInternalRangeValue(value);
        if (value) {
          onRangeChange?.(value, [formatDate(value.start), formatDate(value.end)]);
        } else {
          onRangeChange?.(null, ['', '']);
        }
      },
      getDateString: () => formatDate(internalValue),
      getRangeDateString: () =>
        internalRangeValue ? [formatDate(internalRangeValue.start), formatDate(internalRangeValue.end)] : null,
      focus: () => {
        // èšç„¦é€»è¾‘
      },
      blur: () => {
        // å¤±ç„¦é€»è¾‘
      },
      open: () => {
        setIsOpened(true);
        onOpenChange?.(true);
      },
      close: () => {
        setIsOpened(false);
        onOpenChange?.(false);
      },
      clear: () => {
        if (range) {
          setInternalRangeValue(null);
          onRangeChange?.(null, ['', '']);
        } else {
          setInternalValue(null);
          onChange?.(null, '');
        }
      },
      disable: () => {
        // ç¦ç”¨é€»è¾‘
      },
      enable: () => {
        // å¯ç”¨é€»è¾‘
      },
      isOpen: () => isOpened,
      isDisabled: () => disabled,
      isReadOnly: () => readOnly,
    }),
    [internalValue, internalRangeValue, formatDate, onChange, onRangeChange, onOpenChange, disabled, range, isOpened],
  );

  return (
    <View
      ref={pickerRef}
      className={pickerClassName}
      style={pickerStyle}
      accessible={accessible}
      accessibilityLabel={accessibilityLabel}
      accessibilityRole={accessibilityRole}
      {...restProps}
    >
      {renderInput()}

      {isOpened && !disabled && !readOnly && (
        <View className="taro-uno-datepicker__panel">
          <ScrollView className="taro-uno-datepicker__panel-content">{renderCalendar()}</ScrollView>
        </View>
      )}
    </View>
  );
});

/** æ—¥æœŸé€‰æ‹©å™¨ç»„ä»¶æ˜¾ç¤ºåç§° */
DatePickerComponent.displayName = 'DatePicker';

/** å¯¼å‡ºæ—¥æœŸé€‰æ‹©å™¨ç»„ä»¶ */
export default DatePickerComponent;
